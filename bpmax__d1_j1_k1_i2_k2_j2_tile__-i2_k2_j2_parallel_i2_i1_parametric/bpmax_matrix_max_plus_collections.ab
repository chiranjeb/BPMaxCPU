affine bpmax_register_tile
{
	M, N, N_sec, N_tile, I1, J1, I2, J2, i3_offset, j3_offset | 
	M >= 16 &&  N >= 96 &&  N_sec >= 1 && N_tile >= 96 && 0<=I1<=J1<=M-1 && 0<=I2<=J2<=N_sec-1 && 0 <= i3_offset <= N_tile-1 && 0 <= j3_offset <= N_tile-1
}
input
   float FTable_2D_1 { i3, j3| 0<=i2<=j2<=N_sec-1 &&  0<=i3<=N_tile && 0<=j3<=N_tile-1 };
   float FTable_2D_2 { i3, j3| 0<=i2<=j2<=N_sec-1 &&  0<=i3<=N_tile && 0<=j3<=N_tile-1 };
output
   float FTable_output { i3, j3| 0<=i2<=j2<=N_sec-1 &&  0<=i3<=N_tile && 0<=j3<=N_tile-1 };
let
	FTable_output[i3, j3] = 0;
.


affine bpmax_matrix_max_plus
{
	M, N, N_sec, N_tile, I1, J1, I2, J2, i3_offset, j3_offset | 
	M >= 16 &&  N >= 96 &&  N_sec >= 1 && N_tile >= 96 && 0<=I1<=J1<=M-1 && 0<=I2<=J2<=N_sec-1 && 0 <= i3_offset <= N_tile-1 && 0 <= j3_offset <= N_tile-1
}
input
   float FTable_4D_1     { i2, j2, i3, j3| 0<=i2<=j2<=N_sec-1 &&  0<=i3<=N_tile && 0<=j3<=N_tile-1 };
   float FTable_4D_2     { i2, j2, i3, j3| 0<=i2<=j2<=N_sec-1 &&  0<=i3<=N_tile && 0<=j3<=N_tile-1 };
output
   float FTable_4D_output { i2, j2, i3, j3| 0<=i2<=j2<=N_sec-1 &&  0<=i3<=N_tile && 0<=j3<=N_tile-1 };
   float FTable_4D_output { i2, j2, i3, j3| 0<=i2<=j2<=N_sec-1 &&  0<=i3<=N_tile && 0<=j3<=N_tile-1 };

let
	use { ek | I2<=ek<=J2 } 
    	bpmax_register_tile[M, N, N_sec, N_tile, I1, J1, ei2, ej2, 0, 0] 
    	    ( 
	      		(ek, i2, j2, i3, j3 -> i2,   ek2, i3, j3)@FTable_4D_1,
	      		(ek, i2, j2, i3, j3 -> ek2+1, j2, i3, j3)@FTable_4D_2
	      	)
	returns (FTable_4D_max_plus);
	  		
	FTable_4D_output[i3, j3] = case { | i2 == N} : 0;
	         		             	{ | i2 < N } : FTable_4D_max_plus;
	         		 		   esac; 
.
