affine bpmax_matrix_max_plus_collections
{
	M, N, N_sec, N_tile, N_tile_div_MR, N_tile_div_NR, MR, NR,  I2, J2| 
	M >= 16 &&  N >= 96 &&  N_sec >= 1 && N_tile >= 96 && N_tile_div_MR >=1 &&
	N_tile_div_NR >=1 && MR >=1 && NR>=1 &&
	0<=I2<=J2<=N_sec-1 && I2 <= J2
}
input
   float FTable_6D_1 { i2, j2, i3, j3, i4, j4 |  0<=i2<=j2<=N_sec-1 &&  0<=i3<=N_tile && 0<=j3<=N_tile-1 && 0<=i4<=MR-1 && 0<=j4<=NR-1};
   float FTable_6D_2 { i2, j2, i3, j3, i4, j4 | 0<=i2<=j2<=N_sec-1 &&  0<=i3<=N_tile && 0<=j3<=N_tile-1 && 0<=i4<=MR-1 && 0<=j4<=NR-1};
output
   float FTable_Section {i3, j3, i4, j4 | 0<=i3<=N_tile && 0<=j3<=N_tile-1 && 0<=i4<=MR-1 && 0<=j4<=NR-1};
let
	FTable_Section[i3, j3, i4, j4] = 0; 
.


affine bpmax_max_r0_single
{   
	M, N, N_sec, N_tile, N_tile_div_MR, N_tile_div_NR, MR, NR | 
	M >= 16 &&  N >= 96 &&  N_sec >= 1 && N_tile >= 96 && N_tile_div_MR >=1 && N_tile_div_NR >=1 && MR >=1 && NR>=1
}
input
    float FTable_6D_1 { i2, j2, i3, j3, i4, j4 |  0<=i2<=j2<=N_sec-1 &&  0<=i3<=N_tile && 0<=j3<=N_tile-1 && 0<=i4<=MR-1 && 0<=j4<=NR-1};
    float FTable_6D_2 { i2, j2, i3, j3, i4, j4 | 0<=i2<=j2<=N_sec-1 &&  0<=i3<=N_tile && 0<=j3<=N_tile-1 && 0<=i4<=MR-1 && 0<=j4<=NR-1};

output
    float FTable_6D {i2, j2, i3, j3, i4, j4 | 0<=i2<=j2<=N_sec-1 &&  0<=i3<=N_tile && 0<=j3<=N_tile-1 && 0<=i4<=MR-1 && 0<=j4<=NR-1};
   	float FTable_6D_3 {i2, j2, i3, j3, i4, j4 | 0<=i2<=j2<=N_sec-1 &&  0<=i3<=N_tile && 0<=j3<=N_tile-1 && 0<=i4<=MR-1 && 0<=j4<=NR-1};
   	  
	let
		use { ei2, ej2 | 0<=ei2<=ej2<=N_sec-1 && ei2 <= ej2} 
    		bpmax_matrix_max_plus_collections[M, N, N_sec, N_tile, N_tile_div_MR, N_tile_div_NR, MR, NR, ei2, ej2]  
    			(
    				(ei2, ej2, i2, j2, i3, j3, i4, j4 -> i2, j2, i3, j3, i4, j4)@FTable_6D_1,
    				(ei2, ej2, i2, j2, i3, j3, i4, j4 -> i2, j2, i3, j3, i4, j4)@FTable_6D_2
    			)
	  			returns (FTable_6D);
	  	//FTable_6D_3[i2, j2, i3, j3, i4, j4] = FTable_6D[i2, j2, i3, j3, i4, j4];
	  	
.
