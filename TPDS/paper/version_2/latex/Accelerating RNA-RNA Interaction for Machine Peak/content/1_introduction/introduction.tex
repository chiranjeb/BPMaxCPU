\IEEEPARstart{R}{ibonucleic} acid (RNA) is the origin of life. It plays an essential role in the coding, decoding, regulating, and expressing genes. RNA is a single strand formed by a sequence of four nucleotides---Adenine (A), Uracil (U), Guanine (G), and Cytosine (C). Different nucleotides may form bonds of varying strength. A single RNA strand folds into itself. Also, two different RNA strands can interact with each other, resulting in the combined secondary structure, which provides valuable information about biological function. Mortimer et al. highlight the emerging relationships between such RNA structure and the regulation of gene expression~\cite{Mortimer_2014}.

RNA-RNA interactions have moved to the spotlight in biology since the mid-1990s with significant RNA interference discovery. Researchers have long been studying these interactions and proposed different models. Chitsaz et al.\cite{Chitsaz2009} developed \textbf{\texttt{piRNA}}, one of the most comprehensive thermodynamic RRI models. Running this compute and the memory-intensive program is exceptionally challenging.
Boroojeny et al. \cite{EbrahimpourBoroojeny2021} retreated
from the comprehensive model and developed BPPart~\cite{EbrahimpourBoroojeny2021}, which reduces the complexity by a constant factor of  $10$ and BPMax which maintains only one table. Still, these implementations suffer from poor performance as the input
sequence size grows.

Performance optimization requires exploiting parallelism and locality at multiple levels. It is a difficult task and often leads to hand-crafted code. Manual optimization is neither easily portable nor easily maintainable. The challenge grows as the complexity of the program increases. Ideally, the optimized programs should be generated from a simple correct input specification, together with a set of performance tuning hints or directives.

Fortunately, RRI algorithms fit the requirements of the \emph{polyhedral model}~\cite{sanjay-fst-tcs, sanjay-thesis, sanjay-dc, quinton84c, quinton, quinton-jvsp89, feautrier91, feautrier92a, feautrier92b}, a mathematical formalism that allows for just such program transformations. The polyhedral compilation has been the subject of intense research for over 35~years. Yet, even state-of-the-art polyhedral tools like  PLUTO~\cite{Bondhugula2015PLuToAP, Bondhugula2008} fail to perform satisfactorily. Specifically, Varadarajan~\cite{Varadarajan2016} evaluated its performance on a simple program whose structure is close to the core computation of RRI algorithms. The performance was significantly lower than the hand-written baseline implementation. Many of the optimization strategies need insights from an expert. This gap can be bridged by tools like Chill~\cite{Chen08chill:a}, Hailde~\cite{RaganKelley2013} and \textsc{\texttt{MMAlpha}}~\cite{guillou-mma} that allow semi-automatic transformation. At CSU, we are developing and working with \textbf{\alphaz}~\cite{sanjay-lcpc2012}, a similar tool for generating optimized code that raises the level of abstraction. Specifically, our paper makes the following contributions:
\begin{itemize}
\item We show efficient tiling and scheduling of an RRI program - BPMax on a single CPU machine using a polyhedral code generation tool, \textbf{\alphaz}.

\item  We implement a highly optimized max-plus register kernel, which achieves a performance closer to the machine peak and integrates it with our auto-generated code.

\item We generate highly optimized code for BPMax that achieves about $400\times$ speedup over the original program. It is $80\%$ and $53\%$ of our max-plus roofline~\cite{Williams2008} peak on single-core and multi-core, respectively.

\item The most compute-intensive part of BPMax achieves about $400\times$ speedup over the original implementation, and about $4\times$ improvement over a previous optimization approach~\cite{Mondal2021}. It is $90\%$ and $58\%$ of our platform's max-plus roofline peak on single-core and multi-core, respectively.
\end{itemize}


