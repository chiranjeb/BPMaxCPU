\input{content/4_Implementation/schedules/bpmax_original_schedule}

\input{content/4_Implementation/schedules/bpmax_hybrid_schedule_with_two_level_tiling}


\subsection{New BPMax Schedules}
We used the BPMax equation as specified in the original paper ~\cite{EbrahimpourBoroojeny2021} in our previous optimization work ~\cite{Mondal2021}. In our current optimization work, we manually transform the original BPMax equations to apply the second and third-level tiling based on a mono-parametric tile parameter and develop a modified \alfa program. It allows precise scheduling, memory mapping, and transformations of the second-level tiles. We express various computations using subsystems and apply optimization on each of them independently to produce modular code.

Similar to the prior optimization work, we compute the $S^{(1)}$ and $S^{(2)}$ table first. However, we apply mono-parametric tiling on $S^{(2)}$ so that we can use a second-level tile as one of the matrix max-plus operands for computing $R^{1}$ and  $R^{2}$. Let us now discuss the $F$-table schedules at the different tiling levels.

\textbf{First-level Tile Schedule:}
Each first-level tile (an inner triangle) goes through different computation phases (point-wise operations and reductions) associated with a unique subsystem. The point-wise operations initialize (subsystem - $Initialization$) the $F$-table and update (subsystem - $Point\-wise^{sw}$) using the inner triangle to its south-west. Subsystem - $Reductions^{outer}$ accumulates the result from the outer reductions - $R^{0}$, $R^{3}$, $R^{4}$ and subsystem - $Reductions^{inner}$ makes the final update to each tile using the inner reductions - $R^{1}$, $R^{2}$. We process diagonal tiles one at a time for invoking point-wise operations ($Initialization$ and $Point\-wise^{sw}$) and outer reductions $Reductions^{outer}$. $Reductions^{outer}$ accumulates the results from a set of $F(i_{1}, k_{1})$ and $F(k_{1}+1, j_{1})$ triangles where $i_{1} \le k_{1} < j_{1}$.  $2^{nd}$ and $3^{rd}$ dimensions of these subsystem's schedules control the diagonal processing order. \input{content/4_Implementation/schedules/tile_l1_top_level}
Notice that initialization of the entire $F$-table is costly due to its footprint. So, we schedule $Initialization$ and $Point\-wise^{sw}$ together ($5^{th}$ and $6^{th}$ dimension of the schedule) before scheduling the $Reductions^{outer}$ (ordering is controlled by the $4^{th}$ dimension of the schedule). After completing all the outer reductions, we schedule $Reductions^{inner}$ ($3^{rd}$ dimension greater than $M-1$) for multiple tiles simultaneously. Table~\ref{tab:tile_l1} outlines the schedule for each one of these subsystems along with $S^{(1)}$ and $S^{(2)}$. The parallel dimension 5 indicates that multiple threads are assigned to do point-wise operations on a particular tile, whereas each tile is finalized ($Reductions^{inner}$) by one thread.


\textbf{Second-level Tile Schedule:} Second-level tiles are processed by $Reductions^{outer}$ and $Reductions^{inner}$ subsystems. $Reductions^{outer}$ accumulates partial results for all the second-level tiles $\{ i_{2}, j_{2} \mid 0 \le i_{2} \le j_{2} \le N_{sec}-1 \}$ for a given first-level tile $F(i_{1}, j_{1})$. It is responsible for scheduling $R^{3}$ (subsystem - $R^{3}_{t}$), $R^{4}$ (subsystem - $R^{4}_{t}$), multiple matrix max-plus input transformations (subsystem - $MT(F)^{A}$ and $MT(F)^{B}$), and multiple matrix max-plus computations (subsystem - $MMP$). For matrix max-plus operation, each second-level tile $F(i_{1}, j_{1}, i_{2}, j_{2})$ is updated using a set of input tiles $F(i_{1}, k_{1}, i_{2}, k_{2})$ and $F(k_{1}+1, j_{1}, k_{2}, j_{2})$ where $i_{2} \le k_{2} \le j_{2}$. As noted earlier, instead of evaluating one output tile at a time, we use a schedule that accumulates results in the output tile. Since $R^{0}$, $R^{3}$, $R^{4}$ share the input tiles, we first schedule the $R^{3}_{t}$ and $R^{4}_{t}$ and reuse the input tiles in $MMP$. We schedule $MT(F)^{A}$ to transform an input tile and use it multiple times as the first operand in a $MMP$ invocation. Before each $MMP$ invocation, we schedule $MT(F)^{B}$ to transform the second operand of the matrix max-plus operation. Table~\ref{tab:bpm_l2_outer_reduction_schedule} highlights the schedule for the different subsystems invoked from $Reductions^{outer}$.
\input{content/4_Implementation/schedules/tile_l2_outer_reductions} 
\input{content/4_Implementation/schedules/tile_l2_inner_reductions}
$Reductions^{inner}$ subsystem takes a first-level tile $F(i_{1}, j_{1})$ and $S_{2}$ as input and makes the final update to the $F(i_{1}, j_{1})$. It is responsible for scheduling a diagonal tile (subsystem - $DiagonalTile$), optimized $R_{1}$ (subsystem - $MT(S^{2})^{A}$, $MT(F)^{B}$, $MMP$), optimized $R_{1}$ ($MT(F)^{A}$, $MT(S^{2})^{B}$, $MMP$) and residual patch up computation ($Finalize$). Table~\ref{tab:bpm_l2_outer_reduction_schedule} highlights a bottom-up and left-to-right schedule for these subsystems. So, we first schedule the $DiagonalTile$ tile corresponding to each tile row. For each non-diagonal tile, we schedule all the subsystems that optimize the $R^{1}$, followed by $R^{2}$. Scheduling these subsystems is similar to optimizing $R^{0}$. Finally, we schedule $Finalize$ for each non-diagonal tile to resolve the intra-tile dependencies.

\begin{table*}[htbp]
\caption{\uppercase{Register allocation Strategy}}
\label{tab:ymm_registers}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
Number & Number & Number of& Number of & Number of YMMs & Total &Number of & Number of   \\
of A & of B & YMMs for A & YMMs for  B&  for accumulations&YMMs Usage &Memory access&  Max-plus  Operations(v)\\
\hline
2 & 24 & 2 & 3 & 6 & 11  & 5 & 6 \\
\hline
2  & 32 & 2 & 4 & 8 & 14 & 6 & 8  \\
\hline
3 & 24 & 3 & 3 & 9 & 15  & 6 & 9 \\
\hline
3 & 16 & 3 & 2 & 6 & 11 & 5 & 6  \\
\hline
4 & 16 & 4 & 2 & 8 & 14  & 6 & 8  \\
\hline
\end{tabular}
\end{center}
\end{table*}

\input{content/4_Implementation/handwritten_kernels}


