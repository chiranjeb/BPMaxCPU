float e_intra_score (int,int) ;
float e_inter_score (int,int) ;



affine bpmax_single_strand_s1 {M|M>=3}
input
    int seq1 {i| 0 <= i < M };
output
	float S1 {i,j| 0 <= i <= j < M};
	let
		S1[i,j] = case
		{ | j-i<= 3}: 0 ;
		{ | j-i > 3}: max(S1[i+1,j-1] + e_intra_score (seq1[i],seq1[j]),
					   reduce(+, [k], {|k<j}:S1[i,k]+S1[k+1,j]));
	esac;
.

affine bpmax_single_strand_s2 {N|N>=3}
input
    int seq2 {i| 0 <= i < N };
output
	float S2 {i,j| 0 <= i <= j < N};
	let
	S2[i,j] = case
		{ | j-i<= 3}: 0 ;
		{ | j-i > 3}: max (S2[i+1,j-1] + e_intra_score (seq2[N-i-1],seq2[N-j-1]),
					  reduce(+, [k], {| k<j}:S2[i,k]+S2[k+1,j]));
	esac;
.



affine bpmax_outer_reductions{ M, N, I1, J1, T1 , T2, T3| M>=8 && N>=8 && T1 >=1 && T2 >=1 && T3 >= 1 &&  M>=J1+1 && I1>=0 && J1> I1}
	input
       float FTable  {i1,j1,i2,j2| 0<=i1<=j1<=M-1 && 0<=i2<=j2<=N-1};
       float S1 {i,j| 0 <= i <= j < M };
	output
	  float Outer_Max_Res  {i,j| 0<=i<=j<=N-1};
	let
	  Outer_Max_Res[i,j]=0; // This will be replaced by the outer 
.

 
 
affine bpmax_inner_reductions{M, N, I1, J1, T1 , T2, T3| M>=8 && N>=8 && T1 >=1 && T2 >=1 && T3 >= 1 &&  0<=I1<=J1<=M-1}
	input
	  float FTable {i1,j1,i2,j2| M>=j1+1 && i2>=0 && N>=j2+1 && j2>=i2 && i1>=0 && j1>=i1 } ;
	  float S2 {i,j| i>=0 && N>=j+1 && j>=i } ; 
	  int seq2 {i| 0 <= i < N} ;
	output
	  float _FTable  {i,j| 0<=i<=j<=N-1};
	let
	  _FTable[i,j]=0; // do not initialize
.



affine bpmax_elementwise_ops{M, N, I1, J1| M>=8 && N>=8 && 0<=I1<=J1<=M-1}

input
	int seq1 {i| 0 <= i < M} ;
	int seq2 {i| 0 <= i < N} ;
	float S1 {i,j| 0 <= i <= j < M };
	float S2 {i,j| 0 <= i <= j < N };
    float FTable {i1,j1,i2,j2| M>=j1+1 && i2>=0 && N>=j2+1 && j2>=i2 && i1>=0 && j1>=i1 };
output
	float _FTable  {i,j| 0<=i<=j<=N-1};
	  
let
	 _FTable[i2, j2] = 0;
		
.

affine bpmax {M,N, T1, T2, T3| M>=8 && N>=8 && T1>=1 && T2>=1 && T3>=1}
input
	int seq1 {i| 0 <= i < M} ;
	int seq2 {i| 0 <= i < N} ;
output
	float FTable {i1,j1,i2,j2| 0<=i1<=j1<=M-1 && 0<=i2<=j2<=N-1};
local
	float S1                            {k,i,j| 0<=k<1 && 0 <= i <= j < M };
	float S2                            {k,i,j| 0<=k<1 && 0 <= i <= j < N };
	float FTable_elementwise_ops        {i1,j1,i2,j2| 0<=i1<=j1<=M-1 && 0<=i2<=j2<=N-1};
	float FTable_outer_reductions       {i1,j1,i2,j2| 0<=i1<=M-1 && i1<j1<=M-1 && 0<=i2<=j2<=N-1};
	float FTable_inner_reductions       {i1,j1,i2,j2| 0<=i1<=j1<=M-1 && 0<=i2<=j2<=N-1};
	

let
	// Compute single strand table - S1
	use {ei | ei>=0 && 1>ei }  bpmax_single_strand_s1[M] ((ei, i->i)@seq1) returns  (S1);
	
	// Compute single strand table - S2
	use {ei | ei>=0 && 1>ei }  bpmax_single_strand_s2[N] ((ei, i->i)@seq2) returns  (S2);
	
	// Initialize FTable
	use {ei1,ej1| 0<=ei1<=ej1<=M-1 } 
	    bpmax_elementwise_ops[M, N, ei1, ej1] 
	    ((ei, ej, i->i)@seq1, 
	     (ei, ej, i->i)@seq2, 
	     (ei1, ej1, i1, j1 -> 0, i1, j1)@S1, 
	     (ei1, ej1, i1, j1 -> 0, i1, j1)@S2, 
	     ((ei1, ej1, i1, j1, i2, j2 -> i1, j1, i2, j2)@FTable))
	    returns (FTable_elementwise_ops);
	
	FTable[i1, j1, i2, j2] = 0;
	
	// Do outer reductions
    use {ei1,ej1| ei1>=0 && M>=ej1+1 && ej1>ei1 } 
	    bpmax_outer_reductions[M,N, ei1, ej1, T1, T2, T3] 
	    ((ei1, ej1, i1, j1, i2, j2 -> i1, j1, i2, j2)@FTable, (ei1, ej1, i1, j1 -> 0, i1, j1)@S1) 
	    returns (FTable_outer_reductions);
	    
    // Do inner reductions
	use {ei1,ej1| 0<=ei1<=ej1<=M-1 } 
	    bpmax_inner_reductions[M,N, ei1, ej1, T1, T2, T3] 
	    ((ei1, ej1, i1, j1, i2, j2 -> i1, j1, i2, j2)@FTable, 
	    (ei1, ej1, i1, j1 -> 0, i1, j1)@S2,
	    (ei, ej, i->i)@seq2)
	    returns (FTable_inner_reductions); 
.


