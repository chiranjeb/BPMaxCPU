float e_intra_score (int,int) ;


affine transform_section_like_A_for_register_tile 
{
	M, N, N_sec, N_tile, MR, NR, I2, J2 | 
	M >= 16 &&  N >= 96 &&  N_sec >= 1 && N_tile >= 96 && MR >=1 && NR>=1 && 0<=I2<=J2<=N_sec-1
}
input
	float C  { i2, j2, i3, j3  | 0<=i2<=j2<=N_sec-1 &&  0<=i3<=N_tile-1 && 0<=j3<=N_tile-1 };
output
	float A_2 { i3, j3  |  0<=i3<=N_tile-1 && 0<=j3<=N_tile-1 };
let
	A_2 [i3, j3] = 0;
.

affine transform_section_like_B_for_register_tile 
{
	M, N, N_sec, N_tile, MR, NR, I2, J2 | 
	M >= 16 &&  N >= 96 &&  N_sec >= 1 && N_tile >= 96 && MR >=1 && NR>=1 && 0<=I2<=J2<=N_sec-1
}
input
	float C  { i2, j2, i3, j3  | 0<=i2<=j2<=N_sec-1 &&  0<=i3<=N_tile-1 && 0<=j3<=N_tile-1 };
output
	float B_2 { i3, j3  |  0<=i3<=N_tile-1 && 0<=j3<=N_tile-1 };
let
	B_2 [i3, j3] = 0;
.


affine bpmax_finalize 
{
	M, N, N_sec, N_tile, MR, NR, I2, J2 | 
	M >= 16 &&  N >= 96 &&  N_sec >= 1 && N_tile >= 96 && MR >=1 && NR>=1 && 0<=I2<=J2<=N_sec-1 && I2<J2
}
input
    int   seq2 { i|0<=i<=N-1}; 
	float A  { i2, j2, i3, j3  | 0<=i2<=j2<=N_sec-1 &&  0<=i3<=N_tile-1 &&  0<=j3<=N_tile-1 };
	float B  { i2, j2, i3, j3  | 0<=i2<=j2<=N_sec-1 &&  0<=i3<=N_tile-1 &&  0<=j3<=N_tile-1 };
	float C  { i2, j2, i3, j3  | 0<=i2<=j2<=N_sec-1 &&  0<=i3<=N_tile-1 &&  0<=j3<=N_tile-1 };
	
output
	float C_2 { i3, j3  |  0<=i3<=N_tile-1 && 0<=j3<=N_tile-1 };

let
  C_2[i3,j3] = max (  case { | j3 == 0 && i3  < N_tile-1} : 
  	                           C[I2, J2-1, i3, N_tile-1 ] /* + e_intra_score(seq2[N-i3-1], seq2[N-j3-1])*/ ;
		                   { | j3 == 0 && i3 == N_tile-1} : 
		                   	   case  {|j3-i3  > 3}: C[ I2+1, J2-1, 0, N_tile-1  ] /* + e_intra_score(seq2[N-i3-1], seq2[N-j3-1])*/;
			 	               {|j3-i3  <=3}: 0; esac;
		                   { | j3 >  0 && i3 == N_tile-1} : 
		                       C[ I2+1, J2,   0,    j3-1 ] /*+ e_intra_score(seq2[N-i3-1], seq2[N-j3-1])*/;   
		                   { | j3 >  0 && i3 < N_tile-1 } : 
		                       C[ I2, J2,   i3+1, j3-1 ] /*+ e_intra_score(seq2[N-i3-1], seq2[N-j3-1])*/;
		                 esac
		               ,   
		              max ( A[I2, J2, i3, N_tile-1] + C[I2+1, J2, 0, j3], 
		                    case {| i3 < N_tile-1  } :    reduce(max, [k3], {|i3<=k3<N_tile-1} : A[I2, J2, i3, k3] + C[I2, J2, k3+1, j3]);
		    			         {| i3 == N_tile-1 } : 0; esac,
		                    case {| j3 > 0 } : reduce(min, [k3], {|0<=k3<=j3-1} : C[I2, J2, i3, k3] + B[I2, J2, k3+1, j3]);
		    			         {| j3 ==0 } : 0; esac
		    			  )
		    	   );
.	


affine bpmax_max_matrix_max_plus_section 
{
	M, N, N_sec, N_tile, MR, NR, I2, J2 | 
	M >= 16 &&  N >= 96 &&  N_sec >= 1 && N_tile >= 96 && MR >=1 && NR>=1 && 0<=I2<=J2<=N_sec-1
}
input
	  float A  { i2, j2, i3, j3  | 0<=i2<=j2<=N_sec-1 &&  0<=i3<=N_tile-1 &&  0<=j3<=N_tile-1 };
	  float B  { i2, j2, i3, j3  | 0<=i2<=j2<=N_sec-1 &&  0<=i3<=N_tile-1 &&  0<=j3<=N_tile-1 };
output
   float C_section { i3, j3| 0<=i3<=N_tile-1 && 0<=j3<=N_tile-1 };
let
	C_section[i3,j3] = 0;
.		           		



affine bpmax_inner_diagonal_tile 
{
	M, N, N_sec, N_tile, MR, NR, I2, J2 | 
	M >= 16 &&  N >= 96 &&  N_sec >= 1 && N_tile >= 96 && MR >=1 && NR>=1 && 0<=I2<=J2<=N_sec-1
}
input
   int        seq2 { i|0<=i<=N-1}; 
   float S2   { i2, j2| 0<=i2<=N_tile-1 && 0<=j2<=N_tile-1 };
   
output
   float FTable_C_section { i2, j2| 0<=i2<=N_tile-1 && 0<=j2<=N_tile-1 };
let
	FTable_C_section[i2,j2] = 
		case
			{ | i2 >= j2 } : 
					FTable_C_section[i2, j2];
			{ | i2 < j2  } : 
					max (  
						   max (FTable_C_section[i2, j2], 
			              		case  {|j2-i2  > 3}: FTable_C_section[i2+1, j2-1] /* + todo:e_intra_score(seq2[N-i2-1], seq2[N-j2-1])*/;
			 	                	  {|j2-i2  <=3}: 0; esac
			 	               ), 
            		       reduce(max, [k2],  {|i2<=k2<j2} : FTable_C_section[i2, k2] + S2[k2+1, j2]),
            			   reduce(max, [k2],  {|i2<=k2<j2} : S2[i2, k2]     +  FTable_C_section[k2+1, j2]));
        esac;
.		           		


affine bpmax_inner_reductions
{
	M, N, N_sec, N_tile, MR, NR, I1, J1 | 
	M >= 16 &&  N >= 96 &&  N_sec >= 1 && N_tile >= 96 && MR >=1 && NR>=1 && 0<=I1<=J1<=M-1
}
input
	  int seq2 {i| 0 <= i < N} ;
	  float S2       { i2, j2, i3, j3  | 0<=i2<=j2<=N_sec-1 &&  0<=i3<=N_tile-1 && 0<=j3<=N_tile-1 };
	  float S2_A     { i2, j2, i3, j3  | 0<=i2<=j2<=N_sec-1 &&  0<=i3<=N_tile-1 &&  0<=j3<=N_tile-1 };
	  float S2_B     { i2, j2, i3, j3  | 0<=i2<=j2<=N_sec-1 &&  0<=i3<=N_tile-1 &&  0<=j3<=N_tile-1 };
	  float FTable_C { i2, j2, i3, j3  | 0<=i2<=j2<=N_sec-1 &&  0<=i3<=N_tile-1 && 0<=j3<=N_tile-1 };
output
	  float FTable_A { i2, j2, i3, j3  | 0<=i2<=j2<=N_sec-1 &&  0<=i3<=N_tile-1 && 0<=j3<=N_tile-1 };
	  float FTable_B { i2, j2, i3, j3  | 0<=i2<=j2<=N_sec-1 &&  0<=i3<=N_tile-1 && 0<=j3<=N_tile-1 };


local
	  float FTable_C_section   { i2, j2, i3, j3| 0<=i2<=j2<=N_sec-1 &&  0<=i3<=N_tile-1 && 0<=j3<=N_tile-1 && i2 == j2 };
	  float FTable_C_section_r1 { i2, j2, i3, j3| 0<=i2<=j2<=N_sec-1 &&  0<=i3<=N_tile-1 && 0<=j3<=N_tile-1 && i2 < j2  };
	  float FTable_C_section_r2 { i2, j2, i3, j3| 0<=i2<=j2<=N_sec-1 &&  0<=i3<=N_tile-1 && 0<=j3<=N_tile-1 && i2 < j2 };
	  float FTable_C_section_3 { i2, j2, i3, j3| 0<=i2<=j2<=N_sec-1 &&  0<=i3<=N_tile-1 && 0<=j3<=N_tile-1 && i2 < j2 };

let
   	///////////////////////////////////////////////////////////////////////////////////////////////////////
   	//
   	//
    // Step 1: Compute only the diagonals
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////////////
    
   	// Compute the diagonal tiles
    use { ei2, ej2 | 0<=ei2<=ej2<=N_sec-1 &&   ei2 == ej2 } 
   	bpmax_inner_diagonal_tile[M, N, N_sec, N_tile, MR, NR, ei2, ej2]
   	(
   		(ei2, ej2, i -> i)@seq2,
   		S2
   	) returns (FTable_C_section);
	
  
   	///////////////////////////////////////////////////////////////////////////////////////////////////////
   	//
   	//
    // Step 2: Majority of the computation : Perform matrix max plus for R1 and R2
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////////////
    // Step 2.1 : Do it first with the Bs
    use { ei2, ej2 | 0<=ei2<=ej2<=N_sec-1 &&   ei2 < ej2 } 
    bpmax_max_matrix_max_plus_section[M, N, N_sec, N_tile, MR, NR, ei2, ej2]
    ( 
    	(ei2, ej2, i1, j1, i2, j2 -> i1, j1, i2, j2)@S2_A, 
    	(ei2, ej2, i1, j1, i2, j2 -> i1, j1, i2, j2)@FTable_B
	)returns (FTable_C_section_r1);
	   
	// Step 2.2 : Then do it with the As
   use { ei2, ej2 | 0<=ei2<=ej2<=N_sec-1 &&   ei2 < ej2 } 
    bpmax_max_matrix_max_plus_section[M, N, N_sec, N_tile, MR, NR, ei2, ej2]
    (
    	(ei2, ej2, i1, j1, i2, j2 -> i1, j1, i2, j2)@FTable_A, 
    	(ei2, ej2, i1, j1, i2, j2 -> i1, j1, i2, j2)@S2_B
	)returns (FTable_C_section_r2);
    	


    
    // Final Step : Finalize the section and transform it such that it is ready for the register tile.
	use { ei2, ej2 | 0<=ei2<=ej2<=N_sec-1 &&   ei2 < ej2 } 
    bpmax_finalize[M, N, N_sec, N_tile, MR, NR, ei2, ej2]
    (
    	(ei2, ej2, i -> i)@seq2,
    	(ei2, ej2, i1, j1, i2, j2 -> i1, j1, i2, j2)@S2_A, 
    	(ei2, ej2, i1, j1, i2, j2 -> i1, j1, i2, j2)@S2_B,
    	(ei2, ej2, i1, j1, i2, j2 -> i1, j1, i2, j2)@FTable_C
	)returns (FTable_C_section_3);
	
      
    /// Finally transform the memory for register tiling  
    use { ei2, ej2 | 0<=ei2<=ej2<=N_sec-1 } 
    transform_section_like_A_for_register_tile[M, N, N_sec, N_tile, MR, NR, ei2, ej2]
    (
    	(ei2, ej2, i1, j1, i2, j2 -> i1, j1, i2, j2)@FTable_C
    )
    returns (FTable_A);
 	   
	use { ei2, ej2 | 0<=ei2<=ej2<=N_sec-1 } 
	transform_section_like_B_for_register_tile[M, N, N_sec, N_tile, MR, NR,  ei2, ej2]
    (
    	(ei2, ej2, i1, j1, i2, j2 -> i1, j1, i2, j2)@FTable_C
    ) returns (FTable_B);
    
.

